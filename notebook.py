# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eGhDCeE7dvtdelBgcl-eaGfukFW4TeMZ

# Proyek Machine Learning Terapan

COHORT ID : MC008D5X2466  
Nama : Gabriella Yoanda Pelawi  
Email : mc008d5x2466@student.devacademy.id

## 1. Data Loading
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.metrics import confusion_matrix

"""Dataset yang digunakan adalah data [Employee Attrition](https://www.kaggle.com/datasets/stealthtechnologies/employee-attrition-dataset/data) berbentuk csv yang diambil dari Kaggle."""

data = pd.read_csv("employee_attrition.csv")
data

"""Dataset yang akan digunakan tidak memerlukan variabel Employee ID sehingga dibuat data frame baru tanpa variabel Employee ID."""

df = data.drop('Employee ID', axis=1)

"""## 2. Data Understanding

### 2.2 Exploratory Data Analysis
Exploratory Data Analysis (EDA) merupakan proses awal untuk menganalisis karakteristik, pola, anomali dan memeriksa asumsi pada data.

#### 2.2.1 Struktur Data
"""

df.shape

"""Data Employee Atrittion terdiri atas 14900 baris dan 23 kolom."""

print(df.dtypes)

"""Berdasarkan output di atas, terdapat 7 kolom dengan tipe data integer, dan 16 kolom dengan tipe data object.

**Deskripsi Statistik**

Dilakukan pengecekan deskripsi statistik dari data numerik. Berdasarkan output di bawah, didapatkan deskripsi statistik berupa jumlah sampel data (count), nilai rata-rata (mean), standar deviasi (std), nilai minimum (min), kuartil bawah/Q1 (25%), kuartil Tengah/Q2 (50%), kuartil atas/Q3 (75%), dan nilai maksimum (max).
"""

df.describe()

"""#### 2.2.2 Missing Values

Dilakukan pengecekan missing values untuk melihat apakah terdapat nilai yang hilang pada data. Namun, pada data ini tidak ditemukan adanya missing values sehingga dapat dilakukan analisis selanjutnya.
"""

df.isnull().sum()

"""#### 2.2.3 Data Duplikat

Dilakukan pengecekan untuk melihat apakah terdapat data yang terduplikat, tetapi tidak ditemukan adanya duplikasi pada data.
"""

df.duplicated().sum()

"""#### 2.2.4 Outliers

Dilakukan pengecekan apakah terdapat outliers pada data dengan menggunakan visualisasi boxplot.
"""

numeric_df = df.select_dtypes(include=['int64', 'float64'])

plt.figure(1, figsize=(21, 39))
n = 0

for col in numeric_df:
    n += 1
    plt.subplot(5, 4, n)
    plt.subplots_adjust(hspace=0.25, wspace=0.25)
    sns.boxplot(y=df[col], color='lightblue')
    plt.title(f'Boxplot of {col}')

plt.show()

"""Dari visualisasi di atas, terlihat bahwa terdapat outlier pada variabel Years at Company dan Monthly Income.

Untuk mengatasi outlier, akan dibuat batas bawah dengan mengurangi Q1 dengan 1.5/IQR dan batas atas menambah 1.5/IQR dengan Q3.

Kemudian membuat rumus IQR (Inter Quartile Range) = Q3 - Q1
"""

for col in numeric_df.columns:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    df[col] = np.where(df[col] < lower_bound, lower_bound, df[col])
    df[col] = np.where(df[col] > upper_bound, upper_bound, df[col])

plt.figure(1, figsize=(21, 39))
n = 0

for col in numeric_df:
    n += 1
    plt.subplot(6, 3, n)
    plt.subplots_adjust(hspace=0.25, wspace=0.25)
    sns.boxplot(y=df[col], color='lightblue')
    plt.title(f'Boxplot of {col} after normalized')

"""Berdasarkan output diatas, terlihat bahwa sudah tidak ada outlier pada variabel numerik sehingga dapat dilakukan analisis selanjutnya.

#### 2.2.5 Univariate Analysis

##### a. Fitur Kategorik

**Distribusi Pemutusan Hubungan Kerja (attrition)**
"""

plt.figure(figsize=(7,4))
sns.countplot(data=df, x='Attrition')
plt.title("Distribusi Attrition")
plt.xlabel("Rating")
plt.ylabel("Jumlah Karyawan")
plt.show()

"""Visualisasi ini menunjukkan bahwa mayoritas karyawan memilih untuk tetap bekerja di perusahaan dibandingkan dengan mereka yang keluar.

**Distribusi Gender Pekerja**
"""

gender_counts = df['Gender'].value_counts()

# Pie chart
plt.figure(figsize=(6,6))
plt.pie(gender_counts, labels=gender_counts.index, autopct='%1.1f%%', startangle=90, colors=plt.cm.Paired.colors)
plt.title("Distribusi Jenis Kelamin Karyawan")
plt.axis('equal')
plt.show()

"""Berdasarkan diagram pie, terlihat bahwa karyawan perempuan (54,3%) mendominasi tenaga kerja di perusahaan ini dibandingkan laki-laki (45,7%). Komposisi ini menunjukkan bahwa perusahaan memiliki keberagaman gender, namun juga cenderung lebih banyak mempekerjakan perempuan.

**Distribusi Bidang Pekerjaan**
"""

plt.figure(figsize=(7,4))
sns.countplot(data=df, x='Job Role')
plt.title("Distribusi Bidang Pekerjaan")
plt.xlabel("Bidang Pekerjaan")
plt.ylabel("Jumlah")
plt.show()

"""Visualisasi ini menunjukkan bahwa bidang Teknologi memiliki jumlah karyawan terbanyak, diikuti oleh Healthcare dan Education. Sementara itu, bidang Media dan Finance memiliki jumlah karyawan paling sedikit.

**Distribusi Fitur Kepuasan Kerja Pekerja**
"""

blue_color = "#1a669c"
fig, axes = plt.subplots(1, 3, figsize=(14, 7))
fig.suptitle("Distribusi Fitur Kepuasan Kerja Pekerja", fontsize=16)

# Plot 1 - Aspiration
sns.countplot(data=df, x='Work-Life Balance', ax=axes[0], color=blue_color)
axes[0].set_title('Work-Life Balance')
axes[0].set_ylabel('Jumlah')
axes[0].set_xlabel('Tingkat Work-Life Balance')

# Plot 2 - Number of Doors
sns.countplot(data=df, x='Job Satisfaction', ax=axes[1], color=blue_color)
axes[1].set_title('Job Satisfaction')
axes[1].set_ylabel('Jumlah')
axes[1].set_xlabel('Tingkat Job Satisfaction')

# Plot 3 - Fuel Type
sns.countplot(data=df, x='Performance Rating', ax=axes[2], color=blue_color)
axes[2].set_title('Performance Rating')
axes[2].set_ylabel('Jumlah')
axes[2].set_xlabel('Tingkat Performance Rating')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""- Distribusi tingkat keseimbangan kerja dan kehidupan pribadi menunjukkan bahwa sebagian besar karyawan menilai kondisi mereka sebagai “Good”, disusul oleh “Fair”. Hanya sedikit karyawan yang merasakan work-life balance yang “Excellent” atau “Poor”.
- Sebagian besar karyawan menilai tingkat kepuasan kerja mereka sebagai “High”, dengan jumlah yang jauh lebih sedikit berada pada kategori “Very High”, “Medium”, dan “Low”. Artinya, secara umum karyawan merasa puas terhadap pekerjaan mereka, meskipun tingkat kepuasan tertinggi belum banyak tercapai.
- Sebagian besar karyawan mendapatkan penilaian kinerja pada kategori “Average”. Sementara itu, hanya sebagian kecil yang berada di kategori “High”, “Below Average”, atau “Low”. Hal ini mengindikasikan bahwa penilaian performa cenderung berada di tengah, mungkin karena standar evaluasi yang moderat atau performa rata-rata karyawan yang merata.

**Distribusi Fitur Performa Kerja Pekerja**
"""

blue_color = "#1a669c"
fig, axes = plt.subplots(2, 2, figsize=(7, 7))
fig.suptitle("Distribusi Fitur Performa Kerja Karyawan", fontsize=16)

# Plot 1 - Aspiration
sns.countplot(data=df, x='Overtime', ax=axes[0, 0], color=blue_color)
axes[0, 0].set_title('Jam Kerja Karyawan')
axes[0, 0].set_ylabel('Jumlah')
axes[0, 0].set_xlabel('Overtime')

# Plot 2 - Number of Doors
sns.countplot(data=df, x='Remote Work', ax=axes[0, 1], color=blue_color)
axes[0, 1].set_title('Remote Work')
axes[0, 1].set_ylabel('Jumlah')
axes[0, 1].set_xlabel('Remote Work')

# Plot 3 - Fuel Type
sns.countplot(data=df, x='Leadership Opportunities', ax=axes[1, 0], color=blue_color)
axes[1, 0].set_title('Leadership Opportunities')
axes[1, 0].set_ylabel('Jumlah')
axes[1, 0].set_xlabel('Leadership Opportunities')

# Plot 4 - Engine Location
sns.countplot(data=df, x='Innovation Opportunities', ax=axes[1, 1], color=blue_color)
axes[1, 1].set_title('Innovation Opportunities')
axes[1, 1].set_ylabel('Jumlah')
axes[1, 1].set_xlabel('Innovation Opportunities')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""- Mayoritas karyawan tidak bekerja lembur (overtime), menunjukkan bahwa sebagian besar beban kerja kemungkinan masih dalam batas normal. Hanya sebagian kecil karyawan yang bekerja melebihi jam kerja reguler.
- Kebanyakan karyawan tidak bekerja secara remote. Hal ini menunjukkan bahwa perusahaan cenderung mengadopsi sistem kerja on-site, meskipun ada sebagian kecil karyawan yang bekerja secara remote.
- Sebagian besar karyawan tidak memiliki peluang kepemimpinan, yang menunjukkan bahwa peran kepemimpinan mungkin masih terbatas pada level tertentu saja. Hanya sebagian kecil yang mendapatkan peluang tersebut.
- Distribusi juga menunjukkan bahwa mayoritas karyawan tidak memiliki peluang untuk berinovasi. Ini bisa menjadi indikator penting untuk evaluasi iklim inovasi di perusahaan.

**Distribusi Fitur Latar Belakang Pekerja**
"""

fig, axes = plt.subplots(2, 2, figsize=(16, 12))
fig.suptitle("Distribusi Fitur Latar Belakang Pekerja", fontsize=18)

# Plot 1 - Body Style
sns.countplot(data=df, x='Education Level', ax=axes[0, 0], color=blue_color)
axes[0, 0].set_title('Education Level')
axes[0, 0].set_ylabel('Jumlah')
axes[0, 0].set_xlabel('Education Level')

# Plot 2 - Drive Wheels
sns.countplot(data=df, x='Marital Status', ax=axes[0, 1], color=blue_color)
axes[0, 1].set_title('Marital Status')
axes[0, 1].set_ylabel('Jumlah')
axes[0, 1].set_xlabel('Marital Status')

# Plot 3 - Engine Type
sns.countplot(data=df, x='Job Level', ax=axes[1, 0], color=blue_color)
axes[1, 0].set_title('Job Level')
axes[1, 0].set_ylabel('Jumlah')
axes[1, 0].set_xlabel('Job Level')

# Plot 4 - Number of Fuel System
sns.countplot(data=df, x='Company Size', ax=axes[1, 1], color=blue_color)
axes[1, 1].set_title('Company Size')
axes[1, 1].set_ylabel('Jumlah')
axes[1, 1].set_xlabel('Company Size')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""- Sebagian besar karyawan memiliki tingkat pendidikan Bachelor’s Degree (Sarjana), disusul oleh Master’s Degree dan Associate Degree. Ini menunjukkan bahwa mayoritas tenaga kerja memiliki latar belakang pendidikan tinggi.
- Karyawan yang sudah menikah merupakan kelompok terbanyak, diikuti oleh yang lajang (single). Jumlah karyawan yang bercerai (divorced) relatif kecil. Komposisi ini menunjukkan bahwa sebagian besar karyawan berada dalam fase kehidupan yang mapan.
- Level pekerjaan terbanyak berada di tingkat “Entry” dan “Mid”, sedangkan posisi “Senior” jumlahnya jauh lebih sedikit. Ini menandakan perusahaan yang mayoritas diisi oleh level staf pelaksana dan menengah.
- Sebagian besar karyawan bekerja di perusahaan berukuran besar (Large), diikuti oleh medium, dan yang paling sedikit di perusahaan kecil (Small). Ini menunjukkan bahwa data cenderung didominasi oleh perusahaan besar.

##### b. Fitur Numerik

**Distribusi Usia Pekerja**
"""

plt.figure(figsize=(8, 5))
sns.histplot(df['Age'], kde=True, color="#1f77b4")
plt.title('Distribusi Usia Pekerja')
plt.xlabel('Age')
plt.ylabel('Frekuensi')
plt.tight_layout()
plt.show()

"""Usia karyawan tersebar cukup merata antara 25 hingga 60 tahun, dengan jumlah terbanyak berada di rentang usia 30–35 tahun. Distribusi ini menunjukkan bahwa perusahaan mempekerjakan tenaga kerja dari berbagai generasi, dengan dominasi usia produktif muda.

**Distribusi Lama Bekerja di Perusahaan**
"""

plt.figure(figsize=(8, 3))
sns.boxplot(x=df['Years at Company'], color="#1f77b4")
plt.title('Boxplot Lama Bekerja di Perusahaan')
plt.xlabel('Years at Company')
plt.tight_layout()
plt.show()

"""Boxplot memperlihatkan bahwa sebagian besar karyawan memiliki masa kerja antara 3 hingga 10 tahun, dengan median sekitar 5–6 tahun. Terdapat beberapa outlier yang menunjukkan adanya karyawan dengan masa kerja yang sangat panjang, bahkan mungkin lebih dari 20 tahun. Ini menandakan adanya kombinasi antara karyawan baru dan yang sudah sangat berpengalaman.

**Distribusi Penghasilan Bulanan**
"""

plt.figure(figsize=(8, 5))
sns.kdeplot(df['Monthly Income'], fill=True, color="#1f77b4")
plt.title('Distribusi Penghasilan Bulanan')
plt.xlabel('Monthly Income')
plt.ylabel('Density')
plt.tight_layout()
plt.show()

"""Kurva distribusi menunjukkan dua puncak (bimodal), yang mengindikasikan adanya dua kelompok penghasilan utama dalam perusahaan. Penghasilan terbanyak berada di kisaran 5.000 hingga 9.000 satuan USD.

**Distribusi Jarak Perusahaan ke Rumah**
"""

plt.figure(figsize=(8, 5))
sns.kdeplot(df['Distance from Home'], fill=True, color="#1f77b4")
sns.rugplot(df['Distance from Home'], color="#1f77b4")
plt.title('Distribusi Jarak dari Rumah ke Kantor')
plt.xlabel('Distance from Home')
plt.ylabel('Density')
plt.tight_layout()
plt.show()

"""Jarak rumah ke kantor relatif tersebar merata hingga sekitar 100 km. Ini menunjukkan bahwa karyawan datang dari berbagai lokasi, baik dekat maupun jauh dari kantor.

#### 2.2.6 Bivariate Analysis

**Korelasi Antar Variabel Numerik**
"""

correlation = df.corr(numeric_only=True)

plt.figure(figsize=(12, 9))
sns.heatmap(correlation, annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Heatmap Korelasi Antar Variabel Numerik")
plt.show()

"""Heatmap korelasi menunjukkan hubungan paling kuat antara “Years at Company” dengan “Age”, serta dengan “Company Tenure”. Ini logis karena semakin lama seseorang bekerja di perusahaan, biasanya semakin lama pula mereka berada dalam peran atau bidang yang sama.

**Distribusi Lama Kerja berdasarkan Kelompok Usia**
"""

df['Age Group'] = pd.cut(df['Age'], bins=[20, 30, 40, 50, 60], labels=['20-30', '31-40', '41-50', '51-60'])

plt.figure(figsize=(8, 5))
sns.boxplot(x='Age Group', y='Years at Company', data=df, color='#1f77b4')
plt.title('Lama Kerja berdasarkan Kelompok Usia')
plt.xlabel('Kelompok Usia')
plt.ylabel('Years at Company')
plt.tight_layout()
plt.show()

"""Boxplot menunjukkan bahwa semakin tua usia karyawan, semakin lama mereka bekerja di perusahaan. Kelompok usia 51–60 tahun memiliki masa kerja paling lama, sementara kelompok usia 20–30 tahun memiliki masa kerja paling pendek.

**Distribusi Variabel Numerik berdasarkan Atrittion**
"""

numerical_vars = [
    'Age', 'Years at Company', 'Monthly Income', 'Performance Rating',
    'Number of Promotions', 'Distance from Home', 'Number of Dependents', 'Company Tenure'
]

n_cols = 3
n_rows = (len(numerical_vars) + n_cols - 1) // n_cols

fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, 5 * n_rows))
fig.suptitle("Bivariate EDA: Variabel Numerik vs Attrition", fontsize=18, y=1.02)

axes = axes.flatten()

# Definisikan warna: stayed = biru, left = merah
color_palette = {"Left": "#1f77b4", "Stayed": "#d62728"}  # No = stayed (biru), Yes = left (merah)

for i, col in enumerate(numerical_vars):
    sns.boxplot(data=df, x='Attrition', y=col, ax=axes[i], palette=color_palette)
    axes[i].set_title(f'{col} vs Attrition')
    axes[i].set_xlabel('Attrition')
    axes[i].set_ylabel(col)

for j in range(i + 1, len(axes)):
    axes[j].axis('off')

plt.tight_layout()
plt.show()

"""1. Age vs Attrition
Rata-rata usia karyawan yang keluar sedikit lebih rendah dibandingkan dengan yang bertahan. Ini menunjukkan bahwa karyawan yang lebih muda cenderung lebih mudah meninggalkan perusahaan.

2. Years at Company vs Attrition
Karyawan yang bertahan cenderung memiliki masa kerja lebih lama dibandingkan dengan mereka yang keluar. Hal ini wajar karena masa kerja yang pendek bisa menjadi indikator ketidaknyamanan atau ketidakcocokan.

3. Monthly Income vs Attrition
Karyawan yang keluar memiliki pendapatan bulanan yang sedikit lebih rendah dibandingkan yang bertahan. Ini bisa mengindikasikan bahwa gaji berpengaruh terhadap keputusan keluar.

4. Performance Rating vs Attrition
Tidak terlihat perbedaan signifikan dalam distribusi penilaian kinerja antara yang bertahan dan keluar, artinya attrition tidak terlalu dipengaruhi oleh penilaian kinerja langsung.

5. Number of Companies Worked vs Attrition
Karyawan yang keluar memiliki riwayat bekerja di lebih banyak perusahaan sebelumnya. Ini bisa menandakan pola job-hopping atau ketidaksetiaan terhadap satu tempat kerja.

6. Distance from Home vs Attrition
Tidak terlihat perbedaan yang signifikan. Artinya, jarak tempat tinggal ke kantor bukan faktor utama yang memengaruhi keputusan keluar.

7. Number of Opportunities vs Attrition
Distribusi relatif mirip, sehingga peluang yang tersedia tampaknya bukan faktor utama dalam attrition.

8. Company Tenure vs Attrition
Masa kerja total di perusahaan cenderung lebih pendek pada karyawan yang keluar, sejalan dengan temuan dari fitur “Years at Company”.

**Fitur Kepuasan Kerja vs Attrition**
"""

categorical_vars = [
    'Work-Life Balance','Performance Rating'
]

n_cols = 1
n_rows = (len(categorical_vars) + n_cols - 1) // n_cols

fig, axes = plt.subplots(n_rows, n_cols, figsize=(20, 10 * n_rows))
fig.suptitle("Bivariate EDA: Fitur Kepuasan Kerja vs Attrition", fontsize=18, y=1.02)

axes = axes.flatten()

for i, col in enumerate(categorical_vars):
    sns.countplot(data=df, x=col, hue='Attrition', ax=axes[i], palette='Set1')
    axes[i].set_title(f'{col} vs Attrition')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Jumlah')
    axes[i].tick_params(axis='x', rotation=45)

# Matikan sumbu kosong jika ada
for j in range(i + 1, len(axes)):
    axes[j].axis('off')

plt.tight_layout()
plt.show()

"""1. Work Life Balance vs Attrition
Hampir semua jenis pekerjaan menunjukkan jumlah attrition yang cukup besar, tetapi perbedaan antara yang bertahan dan keluar relatif seimbang, kecuali pada teknologi dan finance yang menunjukkan sedikit lebih banyak yang bertahan.

2. Performance Rating vs Attrition
Karyawan dengan penilaian “Average” mendominasi baik yang keluar maupun bertahan. Mereka dengan “High” rating cenderung bertahan.

**Fitur Performa Jabtan vs Attrition**
"""

# Daftar variabel kategorikal
categorical_vars = [
    'Job Role', 'Job Satisfaction',
    'Education Level',
]

n_cols = 2
n_rows = (len(categorical_vars) + n_cols - 1) // n_cols

fig, axes = plt.subplots(n_rows, n_cols, figsize=(20, 5 * n_rows))
fig.suptitle("Bivariate EDA: Fitur Jabatan vs Attrition", fontsize=18, y=1.02)

axes = axes.flatten()

for i, col in enumerate(categorical_vars):
    sns.countplot(data=df, x=col, hue='Attrition', ax=axes[i], palette='Set1')
    axes[i].set_title(f'{col} vs Attrition')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Jumlah')
    axes[i].tick_params(axis='x', rotation=45)

for j in range(i + 1, len(axes)):
    axes[j].axis('off')

plt.tight_layout()
plt.show()

"""1. Job Role vs Attrition
Hampir semua jenis pekerjaan menunjukkan jumlah attrition yang cukup besar, tetapi perbedaan antara yang bertahan dan keluar relatif seimbang, kecuali pada teknologi dan finance yang menunjukkan sedikit lebih banyak yang bertahan.

2. Job Satisfaction vs Attrition
Karyawan dengan kepuasan kerja tinggi cenderung bertahan, sedangkan mereka yang puas sedang atau rendah lebih rentan keluar.

3. Education Level vs Attrition
Tidak ada pola yang sangat mencolok, tetapi lulusan sarjana (Bachelor’s) memiliki jumlah attrition lebih tinggi dibandingkan lainnya, mungkin karena jumlah mereka juga lebih besar secara umum.

**Performa Kerja vs Attrition**
"""

categorical_vars = [
    'Overtime', 'Remote Work',
    'Leadership Opportunities', 'Innovation Opportunities'
]

n_cols = 2
n_rows = (len(categorical_vars) + n_cols - 1) // n_cols

fig, axes = plt.subplots(n_rows, n_cols, figsize=(20, 5 * n_rows))
fig.suptitle("Bivariate EDA: Performa Kerja vs Attrition", fontsize=18, y=1.02)

axes = axes.flatten()

for i, col in enumerate(categorical_vars):
    sns.countplot(data=df, x=col, hue='Attrition', ax=axes[i], palette='Set1')
    axes[i].set_title(f'{col} vs Attrition')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Jumlah')
    axes[i].tick_params(axis='x', rotation=45)

for j in range(i + 1, len(axes)):
    axes[j].axis('off')

plt.tight_layout()
plt.show()

"""1. Overtime vs Attrition
Proporsi attrition jauh lebih tinggi pada karyawan yang bekerja lembur, menunjukkan bahwa beban kerja berlebih mendorong keinginan untuk keluar.

2. Remote Work vs Attrition
Karyawan yang bekerja remote lebih sedikit yang keluar dibandingkan yang bekerja on-site. Ini menunjukkan bahwa fleksibilitas kerja berkontribusi pada retensi.

3. Leadership Opportunities vs Attrition
Karyawan yang memiliki peluang kepemimpinan cenderung bertahan, sementara mereka yang tidak memiliki peluang tersebut lebih cenderung keluar.

4. Innovation Opportunities vs Attrition
Karyawan dengan peluang inovasi juga menunjukkan tingkat attrition yang lebih rendah, mengindikasikan pentingnya keterlibatan dalam proses kreatif.

**Fitur Latar Belakang Pekerja vs Attrition**
"""

categorical_vars = [
    'Education Level', 'Marital Status', 'Job Level', 'Company Size'
]

n_cols = 2
n_rows = (len(categorical_vars) + n_cols - 1) // n_cols

fig, axes = plt.subplots(n_rows, n_cols, figsize=(20, 5 * n_rows))
fig.suptitle("Bivariate EDA: Fitur Latar Belakang vs Attrition", fontsize=18, y=1.02)

axes = axes.flatten()

for i, col in enumerate(categorical_vars):
    sns.countplot(data=df, x=col, hue='Attrition', ax=axes[i], palette='Set1')
    axes[i].set_title(f'{col} vs Attrition')
    axes[i].set_xlabel(col)
    axes[i].set_ylabel('Jumlah')
    axes[i].tick_params(axis='x', rotation=45)

for j in range(i + 1, len(axes)):
    axes[j].axis('off')

plt.tight_layout()
plt.show()

"""1. Education Level vs Attrition
Tidak ada pola yang sangat mencolok, tetapi lulusan sarjana (Bachelor’s) memiliki jumlah attrition lebih tinggi dibandingkan lainnya, mungkin karena jumlah mereka juga lebih besar secara umum.

2. Marital Status vs Attrition
Karyawan lajang memiliki tingkat keluar lebih tinggi dibandingkan yang sudah menikah. Hal ini bisa dikaitkan dengan kebutuhan stabilitas lebih rendah atau mobilitas lebih tinggi.

3. Job Level vs Attrition
Attrition tertinggi terjadi pada level entry, sementara level senior memiliki tingkat keluar yang rendah. Ini bisa disebabkan oleh loyalitas dan manfaat yang meningkat seiring naiknya jabatan.

4. Company Size vs Attrition
Perusahaan kecil memiliki attrition lebih tinggi dibanding perusahaan besar. Perusahaan besar mungkin memberikan lebih banyak stabilitas atau benefit yang membuat karyawan bertahan.

### 3. Data Preparation
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
from sklearn.preprocessing import LabelEncoder
from imblearn.over_sampling import SMOTE

"""#### 3.1 Encoding Variabel Kategorik"""

target = 'Attrition'
features = ['Age', 'Gender', 'Years at Company', 'Job Role', 'Monthly Income',
            'Work-Life Balance', 'Job Satisfaction', 'Performance Rating',
            'Number of Promotions', 'Overtime', 'Distance from Home',
            'Education Level', 'Marital Status', 'Number of Dependents',
            'Job Level', 'Company Size', 'Company Tenure', 'Remote Work',
            'Leadership Opportunities', 'Innovation Opportunities',
            'Company Reputation', 'Employee Recognition']

X = df[features]
y = df[target]

le_target = LabelEncoder()
y_encoded = le_target.fit_transform(y.astype(str))

for col in X.select_dtypes(include=['object', 'category']).columns:
    le = LabelEncoder()
    X[col] = le.fit_transform(X[col].astype(str))

"""#### 3.2 Standarisasi Fitur Numerik"""

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

"""#### 3.3 Splitting Data"""

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.25, random_state=42, stratify=y)

"""### 4. Modeling"""

from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.ensemble import AdaBoostClassifier
from sklearn.metrics import roc_auc_score, roc_curve

"""#### 4.1 Random Forest"""

param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'max_features': ['auto', 'sqrt', 'log2']
}

rf = RandomForestClassifier(random_state=42)

grid_search = GridSearchCV(estimator=rf,
                           param_grid=param_grid,
                           cv=5,
                           n_jobs=-1,
                           verbose=2,
                           scoring='accuracy')

grid_search.fit(X_train, y_train)

best_rf = grid_search.best_estimator_

# Prediksi dengan model terbaik
y_pred_rf = best_rf.predict(X_test)

"""#### 4.2 Gradient Boosting"""

gb = GradientBoostingClassifier(random_state=42)

param_grid_gb = {
    'n_estimators': [100, 200],
    'learning_rate': [0.01, 0.1],
    'max_depth': [3, 5, 10],
    'subsample': [0.8, 1.0]
}

grid_gb = GridSearchCV(gb, param_grid_gb, cv=5, n_jobs=-1, scoring='accuracy')
grid_gb.fit(X_train, y_train)

y_pred_gb = grid_gb.predict(X_test)
print("Gradient Boosting best params:", grid_gb.best_params_)

"""#### 4.3 XGBoost"""

y_train_xgb = y_train.copy()
y_test_xgb = y_test.copy()

le_xgb = LabelEncoder()
y_train_xgb = le_xgb.fit_transform(y_train_xgb)
y_test_xgb = le_xgb.transform(y_test_xgb)

xgb = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)

# Parameter tuning
param_grid_xgb = {
    'n_estimators': [100, 200, 300],
    'max_depth': [3, 6, 10],
    'learning_rate': [0.001, 0.01, 0.1],
    'subsample': [0.8, 1]
}

grid_xgb = GridSearchCV(xgb, param_grid_xgb, cv=5, n_jobs=-1, scoring='accuracy')
grid_xgb.fit(X_train, y_train_xgb)

# Prediksi dan konversi kembali ke label string
y_pred_xgb = le_xgb.inverse_transform(grid_xgb.predict(X_test))

"""#### 4.4 AdaBoost"""

ada = AdaBoostClassifier(random_state=42)

param_grid_ada = {
    'n_estimators': [50, 100, 200],
    'learning_rate': [0.01, 0.1, 1]
}

grid_ada = GridSearchCV(ada, param_grid_ada, cv=5, n_jobs=-1, scoring='accuracy')
grid_ada.fit(X_train, y_train)

y_pred_ada = grid_ada.predict(X_test)
print("AdaBoost best params:", grid_ada.best_params_)

"""### 5. Evaluasi

#### 5.1 Random Forest
"""

print("Model: Random Forest")
print("Accuracy:", accuracy_score(y_test, y_pred_rf))
print("Classification Report:\n", classification_report(y_test, y_pred_rf, target_names=le_target.classes_))

cm_rf = confusion_matrix(y_test, y_pred_rf)

plt.figure(figsize=(6,4))
sns.heatmap(cm_rf, annot=True, fmt="d", cmap="Blues", xticklabels=set(y_test), yticklabels=set(y_test))
plt.title("Confusion Matrix - Random Forest")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

y_proba_rf = grid_rf.best_estimator_.predict_proba(X_test)[:, 1]
roc_auc_rf = roc_auc_score(y_test, y_proba_rf)

print("ROC-AUC Score:", roc_auc_rf)

"""#### 5.2 Gradient Boosting"""

print("Model: Gradient Boosting")
print("Gradient Boosting Test Accuracy:", accuracy_score(y_test, y_pred_gb))
print(classification_report(y_test, y_pred_gb, target_names=le_target.classes_))

cm_gb = confusion_matrix(y_test, y_pred_gb)

plt.figure(figsize=(6,4))
sns.heatmap(cm_gb, annot=True, fmt="d", cmap="Blues", xticklabels=set(y_test), yticklabels=set(y_test))
plt.title("Confusion Matrix - Random Forest")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

le_gb = LabelEncoder()
y_test_gb_encoded = le_gb.fit_transform(y_test)

y_proba_gb = grid_gb.predict_proba(X_test)[:, 1]

# Hitung ROC-AUC Score
roc_auc_gb = roc_auc_score(y_test_gb_encoded, y_proba_gb)
print("ROC-AUC Score (Gradient Boosting):", roc_auc_gb)

"""#### 5.3 XGBoost"""

print("Model: XGBoost")
print("XGBoost Test Accuracy:", accuracy_score(y_test, y_pred_xgb))
print(classification_report(y_test, y_pred_xgb, target_names=le_target.classes_))

cm_xgb = confusion_matrix(y_test, y_pred_xgb)

plt.figure(figsize=(6,4))
sns.heatmap(cm_xgb, annot=True, fmt="d", cmap="Blues", xticklabels=set(y_test), yticklabels=set(y_test))
plt.title("Confusion Matrix - Random Forest")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

y_proba_xgb = grid_xgb.predict_proba(X_test)[:, 1]
roc_auc_xgb = roc_auc_score(y_test_xgb, y_proba_xgb)
print("ROC-AUC Score (XGBoost):", roc_auc_xgb)

"""#### 5.4 AdaBoost"""

print("AdaBoost Test Accuracy:", accuracy_score(y_test, y_pred_ada))
print(classification_report(y_test, y_pred_ada, target_names=le_target.classes_))

cm_ada = confusion_matrix(y_test, y_pred_ada)

plt.figure(figsize=(6,4))
sns.heatmap(cm_ada, annot=True, fmt="d", cmap="Blues", xticklabels=set(y_test), yticklabels=set(y_test))
plt.title("Confusion Matrix - Random Forest")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

le_ada = LabelEncoder()
y_test_ada_encoded = le_ada.fit_transform(y_test)

y_proba_ada = grid_ada.predict_proba(X_test)[:, 1]
roc_auc_ada = roc_auc_score(y_test_ada_encoded, y_proba_ada)
print("ROC-AUC Score (AdaBoost):", roc_auc_ada)